Linux system:
    - kernel    
    - GNU utilities
    - application
    - graphical desktop

- job of the kernel:
    - memory managment
    - hardware managment
    - file system managment
    - process managment

- shell :
    - read instruction and convert it to something the OS would understand

- "" -> shell can substitue command
- '' -> raw string

commands:
    - ls:
        - to show all files in the directoy use ls 
        - to show hidden file use ls -a
        - to recursive the folder ls -R
        -  to get the long name with filter ls -l my* 
        - [ab] here it is or a or b 
        - [1-9] here it is from 1 to 9
        - [!ab] does not include a or b
        - -1 : show the content of the folder every line represent file 

    - find location -name 
        - ex:
            - find . -name "ahmed"
            - find / . -name  "*.c" 

    - if the command doesnot take from standard input and u want to direct an input to it
        - find . -name="*.c" | rm -> wont work as rm doesnot accept standard input 
        - the soulution is usinf $()
            - rm $(find . -name "*.c")

- tail -n 1:
    - read the last line in a file
- tail -n+2:
    - skip the first 2 and keep reading 
- head -2 :
    - read the first two line in a file


    - touch:
        - to create a file use 
    - cp:
        - to copy a file
        - cp -R /folder/ /anotherFolder

    - mv:
        - to move file 

    - mkdir -p :
        - to make parent directory and child directory 

- kill:
    - send signal tp process based on PID 
    - defualt send TERM signal
    - ex:   
        - kill 3490
- killall:
    - send singal based on name

- mount:
    - if u are not using disturbuation u have to do mount and unmout ur self
    - mount by itself would show the mounted devices on the system
    - mount -t type -o option1,option2 src foldertoMountOn

- umount:
    - unmout device 

- echo:
    - '' or "" to make the string is processed as string not as a special character
- cat:
    - write the data which is from standard input to standard output
    - if u write cat > nameofFile and then command strg+D the data would be written to the file

- if statment:
    - if u want the command to run only if the previous command worked
        - cmd1 && cmd2 && cmd3
    - to run the command if the previous failed
        - cmd1 || cmd2 || cmd3
        - cmd || {echo "failed command"; exit 1}
    using if:
    - one way:
        if condition
        then 
            command 
        elif condition
        then    
            command
        else 
            command 
        fi
    - another way:
        if condition; then
            command 
        fi
    comparison u have to give space between bracket [ $x1 -eq $x2 ]:
        -eq -ne -le -ge -gt -lt 
        if [ 1 le 2 ] 
        then 
    - working with string:
        -n means not empty
        -z means empty
        -d directory
        -f file
        -e exits
    - [[ $var = r* ]]
        - u can use double bracket to support regular expression

    - if [[ x = "$pwd"]]
        - "" to make the output single word
    - if u want to user pattern also use ""
        if [[ "${myvar}" == "*.jpg"]]

- to get user input use $1, $2, $3 so on

- to create subshell use ():
    (cd ..; pwd) -> wont change the currnt directory

- std input output:
    - input output redirect:
        - < input 
        - > output
        - n>& : standard output to n 
            ex: 2>& stndard error to standard output 
        - n<& : standard input to n
        - n>&m -> output m to n
        - 1>file.txt:
            direct standard out to file
        
        - to direct error and output to file
            - cmd >& outfile

        - somecmd > my.file 2>&1
            - standard output to file and then standard error to standartd output which is file
        - somecmd 2>&1 >my.file
            - standard error to standard output which is screen. standard output to file means error still 
            would be sent to the screen
        - pipes are exceptions
            - somecmd 2>& | anothercommand

- string operator:
    - ${varname-:default} -> if the value exit return it otherwise return default
    - ${2-:10} -> return the second parameter pf 10
    - ${varname:=defult} -> if the value exit return it otherwise set it to default an return it"s value
    - ${varname:+ default} -> if exists return default otherwise return null
    - ${var:start:length} -> returnt the string starting from start whith the length
    - ${var#expression} : first match from left return the rest
    - ${var##expression} : the last match from left return rest
    - ${var%expression} : first match from right return the rest 
    - ${var%%expression} : the last match from right return the rest 

- vaiables:
    - to show the enviroment variables:
        - printenv : would show all the variable 

    - var1=value1:
        - to set local variable in a process
        - x=12 -> np space around = is allowed
    - $var1:
        - to read the the variable

    - $PATH:
        - directory where the linux search for command
        - to add extra PATH
            - PATH=$PATH:/newpath/..
        - u can add the current path to the $PATH so u dont want always need to use ./
            PATH="$PATH:."

    - to make the file exectuable:
        chmod +x nameOfFile

- calling scripts:
    - to get the output from script in another script use x = $(script)
        - testing=$(date)
    - $? :
        - to get the exit value of the last script
        - exit 123
    - "$@" "$*":
        - all input argument to exectuable
    - "$#":
        - numbers of command lines variables


    - seperatre variable name from the surroouding string  
        var=ahmed
        - x = ${var}_ali --> x is ahmed_ali 
- read:
    - if u only write read it would get the input from the user and store it in var called REPLY
    - using -p would show the question on the screen and store the answer in variable after the ""
- sed:
    - s = substitue, i = insert before, a = insert after , -n /p to print the mathced lines
    - stream editor to change data
    - it apply command to standard input 
    - sed option script file 
    - sed "s/oldword/newword/"
    - u can give a file to a sed
    - sed "s/old/new/" file.txt
    - to make more than one substitue option 
        sed -e "s/old1/new/1; s/old2/new2/" data.txt
    - to make global substitue per line 
        - sed "s/old/new/g" file.txt
    - to select the line which u would substitue
        - sed "2,3s/old/new/" -> would apply only to line 2 and 3
    - to skip character use \
        - sed "s/\/etc\/pass/\/newetc\/newpassword/"
    - to delete a specifie line use d   
        - sed "/old/d" -> remember there is no s at the begining 
    - to delete any lines between lines
        - sed "/startmatch/,/stopmatch/d"
    - to append data use i  
        sed -i "s/old/new/" file.txt^
    - sed -n "/expression/p"

- awk:
    - print first word of each line
        awk '{print $1}' file  -> it should be single ' not " 
    - to change seperator:
        awk -F, or awk -F- -> change seperator to , or - 

- regular expression:
    - ^start :start with
    - end$ : end with
    - ^$ : empty lines
    - . : any character
    - [] : or and it represent one character
    - [^] : not character
    - [1-9] : range
    - *: means the character before it should appear at least one time
        - sed -n "/th*dfs"/p -> h here is optional
    - [1-9]* : match numbers with undefined length
    - + means at least one
    - ? zero or one means any single character or nothing
        ex:
            program.c program.o program.log
            program.? matches program.c program.o 
    - to work on the line after the line u found 
        - sed "/header/{n ; d}" data1.txt
    {1..9}:
        - means the number from 1 to 9 1 2 3 .. 9
        - echo {1..9}
        - ls *.{zip,pkg}
    - span of character:
        *+?:
            - * : 11*0 : 10 110 11110 1111110
        - | : 
            - or
            - linux|unix 
        - () :
            - group the pattern
            - (yes|Yes) 
         
- grep:
    - print the matched expression
    - grep -i : case insenstive
    - grep -v : not match
    - grep "expression" file
    - -E to use regular expression
    - search for pattern
    - grep options pattern file 
    - grep -v :
        - show lines which do not match the pattern  
    - to specifiy more than one match use -e more than one time
        - grep -e abdel -e ahmed file.txt

- to execute math use (()):
    - va=$((1+1))
    - no need to use $ inside the (()) as it is included in the outter ()

- Signals:
    - SIGKILL = 9 = uncondiotional kill

- initProcess:
    - kernel creates the first process called init and run it
    - process which might start automatically are in some locations
        - first option is: /etc/inittabs 
        - /etc/init.d folder contain scripts which would start at the begining of the system
        - scripts are started via entries under /etc/rcX.d  